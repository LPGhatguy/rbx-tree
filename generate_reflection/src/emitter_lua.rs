use std::io::{self, Write};

use heck::CamelCase;
use lazy_static::lazy_static;
use regex::Regex;
use rbx_dom_weak::RbxValue;

use crate::{
    database::ReflectionDatabase,
    reflection_types::{RbxPropertyType, RbxInstanceClass},
};

lazy_static! {
    static ref LUA_IDENT: Regex = Regex::new("^[a-zA-Z_]+[a-zA-Z0-9_]*$").unwrap();
}

pub fn emit_classes<W: Write>(output: &mut W, database: &ReflectionDatabase) -> io::Result<()> {
    writeln!(output, "-- This file is automatically generated.")?;

    let mut keys: Vec<_> = database.classes.keys().collect();
    keys.sort();

    writeln!(output, "return {{")?;
    for class_name in keys.into_iter() {
        emit_class(output, database.classes.get(class_name).unwrap())?;
    }
    writeln!(output, "}}")?;

    Ok(())
}

fn emit_class<W: Write>(output: &mut W, class: &RbxInstanceClass) -> io::Result<()> {
    writeln!(output, "\t{} = {{", class.name)?;

    if let Some(superclass) = &class.superclass {
        writeln!(output, "\t\tsuperclass = \"{}\",", superclass)?;
    }

    writeln!(output, "\t\tproperties = {{")?;
    for property in class.properties.values() {
        if !LUA_IDENT.is_match(&property.name) {
            continue;
        }

        writeln!(output, "\t\t\t{} = {{", property.name)?;

        write!(output, "\t\t\t\ttype = ")?;
        emit_property_type(output, &property.value_type)?;
        writeln!(output, ",")?;

        write!(output, "\t\t\t\ttags = {{")?;
        for tag in property.tags.into_iter() {
            let tag_name = format!("{:?}", tag);
            write!(output, "{} = true, ", tag_name.to_camel_case())?;
        }
        writeln!(output, "}},")?;

        writeln!(output, "\t\t\t}},")?;
    }
    writeln!(output, "\t\t}},")?;

    emit_defaults(output, class)?;

    writeln!(output, "\t}},")?;
    Ok(())
}

fn emit_defaults<W: Write>(output: &mut W, class: &RbxInstanceClass) -> io::Result<()> {
    let mut keys: Vec<_> = class.default_properties.keys().collect();
    keys.sort();

    writeln!(output, "\t\tdefaults = {{")?;
    for property_name in keys.into_iter() {
        if !LUA_IDENT.is_match(property_name) {
            continue;
        }

        let default_value = class.default_properties.get(property_name).unwrap();

        write!(output, "\t\t\t{} = ", property_name)?;
        emit_value(output, default_value)?;
        writeln!(output, ",")?;
    }
    writeln!(output, "\t\t}},")?;

    Ok(())
}

fn emit_value<W: Write>(output: &mut W, value: &RbxValue) -> io::Result<()> {
    use RbxValue::*;

    match value {
        BinaryString { value } => {
            output.write_all(b"\"")?;
            output.write_all(value)?;
            output.write_all(b"\"")?;
            Ok(())
        }
        Bool { value } => write!(output, "{}", *value),
        CFrame { value } => {
            write!(output,
                "CFrame.new({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {})",
                value[0], value[1], value[2],
                value[3], value[4], value[5],
                value[6], value[7], value[8],
                value[9], value[10], value[11])
        }
        Color3 { value } => write!(output, "Color3.new({}, {}, {})", value[0], value[1], value[2]),
        Color3uint8 { value } => write!(output, "Color3.fromRGB({}, {}, {})", value[0], value[1], value[2]),
        Content { value } => write!(output, "\"{}\"", value),
        Enum { value } => write!(output, "{}", value),
        Float32 { value } => write!(output, "{}", value),
        Float64 { value } => write!(output, "{}", value),
        Int32 { value } => write!(output, "{}", value),
        Int64 { value } => write!(output, "{}", value),
        NumberRange { value } => write!(output, "NumberRange.new({}, {})", value.0, value.1),
        NumberSequence { value } => {
            write!(output, "NumberSequence.new(")?;

            for (index, keypoint) in value.keypoints.iter().enumerate() {
                write!(output, "NumberSequenceKeypoint.new({}, {}, {})",
                    keypoint.time, keypoint.value, keypoint.envelope)?;

                if index < value.keypoints.len() - 1 {
                    write!(output, ", ")?;
                }
            }

            write!(output, ")")
        }
        ColorSequence { value } => {
            write!(output, "ColorSequence.new(")?;

            for (index, keypoint) in value.keypoints.iter().enumerate() {
                write!(output, "ColorSequenceKeypoint.new({}, Color3.new({}, {}, {}))",
                    keypoint.time, keypoint.color[0], keypoint.color[1], keypoint.color[2])?;

                if index < value.keypoints.len() - 1 {
                    write!(output, ", ")?;
                }
            }

            write!(output, ")")
        }
        Rect { value } => {
            write!(output, "Rect.new({}, {}, {}, {})", value.min.0, value.min.1, value.max.0, value.max.1)
        }
        PhysicalProperties { value } => {
            match value {
                Some(props) => {
                    write!(output, "PhysicalProperties.new({}, {}, {}, {}, {})",
                        props.density, props.friction, props.elasticity, props.friction_weight, props.elasticity_weight)
                }
                None => write!(output, "nil")
            }
        }
        Ref { value } => {
            if value.is_some() {
                panic!("Can't serialize non-None Ref");
            }

            write!(output, "nil")
        }
        String { value } => write!(output, "\"{}\"", value),
        UDim { value } => write!(output, "UDim.new({}, {})", value.0, value.1),
        UDim2 { value } => write!(output, "UDim2.new({}, {}, {}, {})", value.0, value.1, value.2, value.3),
        Vector2 { value } => write!(output, "Vector2.new({}, {})", value[0], value[1]),
        Vector2int16 { value } => write!(output, "Vector2int16.new({}, {})", value[0], value[1]),
        Vector3 { value } => write!(output, "Vector3.new({}, {}, {})", value[0], value[1], value[2]),
        Vector3int16 { value } => write!(output, "Vector3int16.new({}, {}, {})", value[0], value[1], value[2]),
        _ => unimplemented!()
    }
}

fn emit_property_type<W: Write>(output: &mut W, property_type: &RbxPropertyType) -> io::Result<()> {
    match property_type {
        RbxPropertyType::Data(name) => {
            write!(output, "{{type = \"Data\", name = \"{:?}\"}}", name)
        }
        RbxPropertyType::Enum(enum_name) => {
            write!(output, "{{type = \"Enum\", name = \"{}\"}}", enum_name)
        }
        RbxPropertyType::UnimplementedType(type_name) => {
            write!(output, "{{type = \"Unimplemented\", name = \"{}\"}}", type_name)
        }
    }
}